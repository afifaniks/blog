{
  
    
        "post0": {
            "title": "\[Book Review\] Robert C. Martin - Clean Code",
            "content": "Chapter 5: Formatting . This chapter talks about code aesthetics. That is how your code should look on the screen. Robert tells us to follow a few things while writing codes to keep them neat. A few notable suggestions from this chapter are – . A source file should be kept small as much as possible. Ideally, it should not be more than 200 lines with a cap of 500 lines. However, it is not a hard and fast rule but desired. | . Horizontally, lines should be small enough so that the reader does not have to scroll to read the line. Bob prefers 120 character limit per line. | . A source file should be arranged as we read news in newspapers. The topmost part should provide a high-level overview and details as we go downwards. For example, the class name should be enough to tell us if it is what we are looking for. | . Codes should be grouped by their concepts. For example, a blank line between imports and the package name, or maybe a blank line between variable declaration and a few operation statements on those variables. | . Variables should be declared close to their usage. Local variables should appear at the start of a function. Similarly, it is advised to declare instance variables at the top of a class. For control variables, they should be inside the scope of their respective loops. | . The ordering of the functions/methods is important. It should be ordered in a downward direction. A function that is called should stay below the caller function unless the language requires it to be declared earlier (For example C, C++). | . Indentation levels are really important for code readability and should be maintained. Even if the function or the scope is short, it is advised not to collapse scopes creating an exception to basic indentation. | .",
            "url": "https://afifaniks.github.io/blog/book%20review/2022/04/26/book-review-clean-code.html",
            "relUrl": "/book%20review/2022/04/26/book-review-clean-code.html",
            "date": " • Apr 26, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://afifaniks.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "সিঙ্গলি লিংকড লিস্ট - সি প্রোগ্রামিং",
            "content": "Singly Linked List . Singly Linked List . আগের অধ্যায়ে আমরা লিংকড লিস্টের যেসব বৈশিষ্ট্য নিয়ে আলোচনা করেছি মোটের উপর সেইসবগুলোই একটি Singly Linked List এর বৈশিষ্ট্য। আমরা পরবর্তী সব জায়গায় একে সংক্ষেপে SLL ডাকব। SLL হল এক ধরণের ডাটা স্ট্রাকচার যেখানে লিস্টের প্রতিটি নোডে ডাটা স্টোর এবং পরবর্তী নোডের রেফারেন্স রাখা হয়। আগের অধ্যায় যদি ঠিকঠাক বুঝে থাক, তাহলে নিশ্চয়ই বুঝতে পারছ স্ট্রাকচারটি কি রকম হবে। আমাদের এমন একটি স্ট্রাকচার ডিফাইন করতে হবে যে স্ট্রাকচারে আমরা ডাটা এবং একই টাইপের পরবর্তী নোডের এড্রেস রাখতে পারব। . SLL এর স্ট্রাকচার . ধরা যাক আমরা কিছু ইন্টিজারের জন্য লিংকড লিস্ট বানাব। তাহলে আমাদের স্ট্রাকচার টা কি রকম হবে? নিচের কোডটা দেখার আগে একটু ভাব! . struct Node { int data; struct node *ptr; }; . এখানে আমরা Node নামে একটি স্ট্রাকচার ডিফাইন করেছি। যার ভিতরে দুইটি ফিল্ড আছে। প্রথমটি ডাটা রাখার জন্য সেটা বুঝতে আশা করি কারোরই প্রবলেম থাকার কথা না। তবে দ্বিতীয় লাইনটি কনফিউজিং! আমি জানি, তুমি যদি এর আগে লিংকড লিস্টের কোড করে না থাক, তবে তোমার মনে প্রশ্ন জাগতেই পারে যে আমরা struct Node এর ভিতরে আবার struct Node কিভাবে লিখলাম! Here comes the fun part! একটু মনোযোগ দিয়ে লক্ষ্য কর, আমরা যখন কোন ইন্টিজারের জন্য পয়েন্টার ডিক্লেয়ার করতাম, তখন কি করতাম? সাধারণভাবেই আমরা লিখতাম, . int *ptr; . তাইনা? অবশ্যই তাই। কারণ আমরা তো একটি ইন্টিজার ভ্যারিয়েবলের রেফারেন্স এই পয়েন্টারে রাখব। সেক্ষেত্রে অবশ্যই ব্যাপারটা এরকমই হবে। এবার আমাদের স্ট্রাকচারটার দিকে লক্ষ্য কর। আমরা আমাদের নোডে কার রেফারেন্স রাখব? অবশ্যই সেইম টাইপের আরেকটি নোডের, তাইনা? সেইম টাইপের আরেকটি নোডের জন্য তো স্ট্রাকচারও সেইম হবে। আর সে জন্যে আমাদের পয়েন্টারের ডাটা টাইপও তো আমাদের নোডের(মানে ডিফাইন করা স্ট্রাকচারের) মতই হবে। ব্যাপারটা তো এমনই হওয়ার কথা। আসলেও তাই। সে কারণেই আমরা আমাদের নোডের পয়েন্টারের টাইপও আমাদের নোডের টাইপই হয়। তাই আমরা লিখি, . struct Node *ptr; //where (struct node) is the Data Type . এই জিনিসটি যদি আমরা ভিস্যুয়ালাইজ করি, তবে দুইটি নোডের ক্ষেত্রে আমরা নিচের ছবিটি দেখতে পাবঃ . . এখানে আমাদের হাতে দুইটি নোড আছে। দুইটি নোডই উপরে ডিফাইন করা স্ট্রাকচার থেকে তৈরি এতে আশা করি কারও কোন সন্দেহ নেই। এবার একটা জিনিস লক্ষ্য কর যে, প্রথম নোডের পয়েন্টারটি কিন্তু দ্বিতীয় নোডকে পয়েন্ট করে আছে। মানে সে দ্বিতীয় নোডের এড্রেসকে ধরে রেখেছে। এখন তোমার কাছে আমার প্রশ্ন হচ্ছে যে, দ্বিতীয় নোডের টাইপ কি? অবশ্যই তুমি যা ভাবছ তাই। এখানে দুটি নোডের টাইপই এক এবং তা হল struct Node. আর আমরা যদি কোন পয়েন্টারে এই নোডের রেফারেন্স রাখতে চাই তাহলে অবশ্যই সে পয়েন্টারের টাইপও তো তাই হবে। সে কারণেই আমাদের পয়েন্টারের টাইপ struct Node. এবার নিশ্চয়ই এই ব্যাপারে আর কোন ঝামেলা থাকার কথা না। তাই যদি হয় তবে এবার SLL তৈরি করা শেখা যাক। . SLL তৈরি করা . SLL তৈরি করার আগে আমাদের কয়েকটা জিনিস মাথায় রাখতে হবে। . লিস্ট তৈরির শুরুতেই আমরা নোড টাইপের একটি পয়েন্টার *head ডিক্লেয়ার করে নেব। এই head আমাদের প্রথম নোডের এড্রেস ধরে রাখবে। পরবর্তীতে আমরা যখনই লিস্ট ট্রাভার্স করব বা লিস্টে কোন রকম ম্যানিপুলেশান করব, তখন এর মাধ্যমেই করব। ইনিশিয়ালি আমরা এতে NULL সেট করে রাখব যাতে আমরা চেক করতে পারি আমাদের লিস্টে কোন এলিমেন্ট আছে কি না! | এরকমই আরেকটি পয়েন্টার নিব *current. current এর কাজ হচ্ছে লাস্ট কোন নোড পর্যন্ত আমরা কাজ করেছি তার এড্রেস ধরে রাখা। এতে করে আমরা যখনই নতুন কোন নোড লিস্টে যোগ করব, তখন current এর পয়েন্টারে নতুব নোডটার এড্রেস এসাইন করে দিলেই হবে। | আমরা প্রতিবার নতুন যেই নোডটা তৈরি করব, ইনিশিয়ালি তার পয়েন্টার পার্টটাতে NULL এসাইন করে রাখব। কারণ, সেটা তো তখন শেষ নোডই। আর আমরা জানি শেষ নোডের পয়েন্টার সবসময় NULL থাকবে যাতে আমরা বুঝতে পারি এটাই লিস্টের শেষ। | . এবার আমাদের লিংকড লিস্টের জন্য কিছু কোড লিখা যাক এবং সেই কোডকে অস্ত্রোপাচার করে দেখা যাক আসলে আমরা কি করছি! . প্রথমেই আমরা লিস্টের জন্য একটি স্ট্রাকচার ডিফাইন করে নিব। . struct node { int data; struct node *next; }; struct node *head = NULL; struct node *current = NULL; . এখানে আমরা আগের মতই একটি স্ট্রাকচার ডিফাইন করেছি যাতে একটি ইন্টিজার ভ্যারিয়েবল এবং একটি পয়েন্টার আছে যা পরবর্তী নোডের এড্রেস রাখবে। আমরা আমাদের স্ট্রাকচার node টাইপের দুইটি পয়েন্টার *head এবং *current ডিক্লেয়ার করেছি। ইনিশিয়ালি আমরা এদের NULL দিয়ে এসাইন করে রেখেছি কারণ ইনিশিয়ালি যেহেতু আমাদের কোন লিস্ট নেই সেহেতু অবশ্যই আমাদের কোন হেড কিংবা কারেন্টও নেই। এবার নিচের কোডটা লক্ষ্য করা যাকঃ . int main() { struct node* newNode = (struct node*)malloc(sizeof(struct node)); if(newNode == NULL) { printf(&quot;Memory allocation failed! n&quot;); exit; } newNode-&gt;data = 5; newNode-&gt;next = NULL; if(head == NULL) { head = newNode; current = newNode; } return 0; } . এই কোডটি উপরের স্ট্রাকচার থেকে লেখা। এখানে আমরা প্রথমেই একটি নোড newNode এর জন্য ডায়নামিকালি মেমোরি এলোকেট করেছি। আমরা জানি, malloc() ফাংশান যদি কোন কারণে মেমোরি এলোকেট করতে না পারে তখন NULL রিটার্ন করে। তাই পরের লাইনে আমরা টেঁস্ট করছি যে malloc() NULL রিটার্ন করছে কি না। তার পরের লাইনে আমরা নতুন নোডের ভ্যালু ৫ এসাইন করে দিচ্ছি এবং উপরের শর্তানুযায়ী ইনিশিয়ালি এর পয়েন্টারকে NULL করে দিচ্ছি। এর পরের লাইনে আমরা টেস্ট করছি যে head কি NULL কি না। যেহেতু এটা আমাদের প্রথম নোড সেহেতু head, NULL-ই থাকবে। আর তাই এটাই আমাদের হেড। আমরা তাই head এ এই নতুন নোডের এড্রেস এসাইন করে দিচ্ছি। আবার যেহেতু এখন এটিই লিস্টে আমাদের একমাত্র নোড তাই আমরা current হিসেবেও নতুন নোডটির এড্রেসই এসাইন করে দিয়েছি। এটা তো গেলো শুধু প্রথম নোডের ক্ষেত্রে। এখন পরবর্তী নোডগুলোর ক্ষেত্রে আমরা কি করতে পারি? . আসলে পরবর্তী সকল নোডের ক্ষেত্রে আমরা একই রকম কাজ করব। সেক্ষেত্রে আমাদের if এর পরে একটি else case জুড়ে দিতে হবে। এবং সেখানে আমরা বলে দিব বাকি সকল নোডের জন্য আমরা কি করব। বাকি সকল নোডের ক্ষেত্রে আমরা যা করব তা হল নতুন নোডের এড্রেস আমরা আমাদের লাস্ট নোড(current) এর পয়েন্টারে এসাইন করে দিব মানে current -&gt; next = newNode করে দিব। এবং যেহেতু তখন নতুন নোডটিই আমাদের শেষ নোড, তাই আমরা current কে আপডেট করে দিয়ে নতুন নোডের এড্রেস current এ এসাইন করে দিব। আরেকটা ব্যাপার হচ্ছে আমরা এই সবটা কাজই তো ডায়নামিকালি করব। তাহলে আমরা কোডটা এমনভাবে লিখব যাতে করে আমরা স্বয়ংক্রিয় ভাবেই নোডগুলো একের পর এক সাজাতে পারি। সেক্ষেত্রে আমরা একটি কাজ করতে পারি সেটি হচ্ছে, ইউজার থেকে প্রথমেই ইনপুট নিয়ে নিব যে আমাদের লিস্টে টোটাল নোড কয়টি হবে। সে অনুযায়ী নিচে একটি কোড লেখা হলঃ . #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct node { int data; struct node *next; }; struct node *head = NULL; struct node *current = NULL; int main() { int n; printf(&quot;Enter how many nodes you want to create: &quot;); scanf(&quot;%d&quot;, &amp;n); while(n--) { struct node* newNode = (struct node*)malloc(sizeof(struct node)); if(newNode == NULL) { printf(&quot;Memory allocation failed! n&quot;); exit; } newNode-&gt;next = NULL; printf(&quot;Enter data for new node: &quot;); scanf(&quot;%d&quot;, &amp;newNode-&gt;data); if(head == NULL) { head = newNode; current = newNode; } else { current-&gt;next = newNode; current = newNode; } } return 0; } . এখানে আমরা যে কাজটি করেছি সেটি হল প্রথমেই ইউজার থেকে ইনপুট নিয়ে নিয়েছি যে আমরা কয়টি নোড তৈরি করব। ইনপুট যত হবে আমাদের নোডও ততটি তৈরি হবে মানে লুপ ততবার চলবে। লুপের শুরুতে আমরা newNode এর জন্যে মেমোরি এলোকেট করেছি। তারপর ইনিশিয়ালি নতুন নোডের পয়েন্টারকে NULL করে দিয়েছি এবং নতুন নোডের জন্য ভ্যালু ইনপুট নিয়েছি। এর পরের লাইনে আমরা টেস্ট করছি যে head, NULL কিনা। head যদি NULL হয় তবে আমাদের নতুন নোডই হেড, এবং যেহেতু আমাদের লিস্টে আপাতত আর কোন নোড নেই তাই সেটিই শেষ নোড বা current. এখন যেহেতু আমাদের হেড আর NULL না, তাই এই প্রোগ্রামের রানটাইমে আর কোন বার এই টেস্ট কেস পাস করবে না। এবং আমরা else case এ চলে যাব। সেখানে আমরা লাস্ট নোড এর পয়েন্টারে নতুন নোডের রেফারেন্স দিয়ে দিচ্ছি মানে current -&gt; next = newNode করে দিচ্ছি। এর মানে হল আমরা লাস্ট নোডের পয়েন্টারে আমাদের নতুন নোডের এড্রেস দিয়ে দিচ্ছি বা লিংক তৈরি করছি। আর যেহেতু তখন এই নতুন নোডটিই আমাদের শেষ নোড তাই current এর রেফারেন্সও আপডেট করে দিচ্ছি। নিচের ভিজ্যুয়ালাইজেশানটি দেখলে আশা করি ব্যাপারটি আরও পরিষ্কার হয়ে যাবে। . When *head is NULL: . . When *head is not NULL(Assigning reference of newNode to current-&gt;next): . Updating *current: . . এবার নিজে নিজে এই কোডটি লিখে ফেল। . SSL প্রিন্টিং/ট্রাভার্সিং** . SSL ট্রাভার্সিং এর ক্ষেত্রে আমরা head থেকে শুরু করে যতক্ষণ না পর্যন্ত ট্রাভার্সিং নোডের রেফারেন্সে NULL না পাব ততক্ষণ পর্যন্ত লুপ চালিয়ে যাব। আর প্রতি ইটারেশান শেষে নোডের রেফারেন্স পরবর্তী নোডের রেফারেন্সে আপডেট করব। এবার নিচের কোডটি দেখার আগে নিজে একটু চেষ্টা করে দেখে নিতে পার। . void printList(struct node* temp) { while(temp!=NULL) { printf(&quot;%d t&quot;, temp-&gt;data); temp = temp-&gt;next; } } . এখানে printList() ফাংশানটিতে আর্গুমেন্ট হিসেবে লিস্টের head কে পাঠাতে হবে। তারপর আমরা হেড থেকে শুরু করে প্রতিটি নোডের ডাটা প্রিন্ট করব এবং প্রিন্ট করা শেষে পরবর্তী নোডের এড্রেস হিসেবে আমাদের ট্রাভার্সিং নোডকে আপডেট করব। এরকম করে চলতে থাকবে যতক্ষণ না পর্যন্ত NULL পাওয়া যায়। নাল পেলে বুঝতে হবে এটিই আমাদের লিস্টের শেষ, তখন লুপ ব্রেক করবে এবং ফাংশানের কাজ শেষ হবে। .",
            "url": "https://afifaniks.github.io/blog/c%20programming/bangla/2017/04/15/singly-linked-list.html",
            "relUrl": "/c%20programming/bangla/2017/04/15/singly-linked-list.html",
            "date": " • Apr 15, 2017"
        }
        
    
  
    
        ,"post3": {
            "title": "লিংকড লিস্ট - সি প্রোগ্রামিং",
            "content": "লিংকড লিস্ট . লিংকড লিস্ট কি? . লিস্ট কি? লিস্ট মানে তালিকা। যেখানে একই ধরণের কিছু তথ্য থাকে। লিস্ট যেকোন ধরণের হতে পারে। বাজারের লিস্ট, ছাত্রদের নামের লিস্ট, গরুছাগলের লিস্ট ইত্যাদি ইত্যাদি। সাধারণ লিস্টের সাথে আমাদের লিস্টের পার্থক্য এই যে, লিংকড লিস্টে আমাদের লিস্টের সবগুলো জিনিস একজনের সাথে আরেকজন লিংকড মানে সোজা বাংলায় যুক্ত থাকবে। . লিংকড লিস্ট কেন ব্যবহার করব? . সাধারণত আমরা একই ধরণের ডাটা টাইপ একসাথে রাখার জন্য যে ডাটা স্ট্রাকচারটি ব্যবহার করি সেটি হচ্ছে অ্যারে। অ্যারেতে একের পর এক ইনডেক্সগুলোতে আমরা ডাটা রাখতে পারি। কিন্তু এর কিছু সীমাবদ্ধতা আছে। যেমন অ্যারে ব্যবহার করার সময় আমাদের আগেই এর সাইজ ডিক্লেয়ার করে দিতে হয়। রানটাইমে আমরা অ্যারের সাইজ পরিবর্তন করতে পারি না। আবার অ্যারেতে নতুন করে ইনসার্শন এবং কোন এলিমেন্ট ডিলিট করাও বেশ খরচ সাপেক্ষ ব্যাপার। অন্য দিকে অ্যারে সিকুয়েনশিয়ালি মেমোরি এলোকেট করে। অনেক বড় সাইজের অ্যারের ক্ষেত্রে সিকুয়েনশিয়ালি এত ফ্রি স্পেস মেমোরিতে নাও থাকতে পারে যার ফলে প্রোগ্রাম ফেইল করবে। আবার কোন কোন ক্ষেত্রে মেমোরি এলোকেট করা গেলেও আমাদের যদি অ্যারের সবগুলো ইনডেক্স ব্যবহারের প্রয়োজন না পরে তবে অনেকটা মেমোরির অপচয় হয় যা একজন প্রোগ্রামার কখনই চাইবে না। লিংকড লিস্ট ব্যবহার করলে এসব সমস্যার সম্মুখীন হতে হয় না। তাছাড়া লিংকড লিস্ট স্ট্যাটিক না বলে এর সাইজ ডিক্লেয়ারের প্রয়োজন পরে না। এর সিকুয়েনশিয়াল ফ্রি মেমোরিরও কোন দরকার পরে না। অন্য দিকে এর এটা ম্যানেজ করাও বেশ সহজ। লিংকড লিস্টে কোন এলিমেন্ট ইনসার্শান এবং ডিলিশান উভয়ের কমপ্লেক্সিটিই O(1). তবে সতর্কবাণী এই যে, পয়েন্টার এবং স্ট্রাকচার সম্পর্কে ক্লিয়ার কন্সেপশান না থাকলে লিংকড লিস্ট বুঝা মোটামুটি অসম্ভব। সুতরাং, আশা করি বুঝতেই পারছ এই দুইটা জিনিস জানা না থাকলে কি করতে হবে! . লিংকড লিস্ট . একটি লিংকড লিস্টের ক্ষুদ্রতম একককে আমরা সাধারণত নোড বলে থাকি। এক বা একাধিক নোড মিলেই লিংকড লিস্ট তৈরি হয়। একটি নোডে সাধারণত দুইটা পার্ট থাকে। একটি পার্টে আমরা ডাটা রাখি এবং অন্য পার্টে বলে দেই যে পরবর্তী নোড যদি থাকে তবে সেটা কোথায় আছে। বুঝতেই পারছ, দ্বিতীয় পার্টটা হল পয়েন্টার পার্ট এবং এই পার্টে আমরা পরবর্তী নোডের মেমোরি লোকেশান ধরে রাখি। ধরা যাক, আমাদের কাছে তিনটি বক্স আছে। প্রতিটি বক্সে আমাদের জন্য কিছু ‘ঘাস-পাতা’ রাখা আছে যেগুলো আমরা খাব। আমরা শুধু জানি প্রথম বক্সটা কোথায় আছে। কিন্তু প্রথম বক্সটাতে আবার ‘ঘাস-পাতার’ সাথে দ্বিতীয় বক্সের ঠিকানাও রাখা আছে। আবার ঠিক একইভাবে দ্বিতীয় বক্সে, তৃতীয় বক্সের ঠিকানা আছে। আবার শেষ বক্সটায় কোন ঠিকানা রাখা নেই, যা দেখে আমরা বুঝব যে আর কোন বক্সও নেই, এবং ‘ঘাস-পাতাও’ নেই। তাহলে আমরা যদি শুধু প্রথম বক্সটা খুঁজে পাই, তাহলে বাকিগুলো খুঁজে পেতে আর কষ্ট হবে না। লিংকড লিস্টেও ঠিক একই রকম পদ্ধতি অনুসরণ করা হয়। আমাদের কাছে শুধুমাত্র প্রথম নোডটির এড্রেস থাকবে। যাকে আমরা হেড বলি। তারপর প্রথম নোডে আমরা পাব দ্বিতীয় নোডের এড্রেস(যদি থাকে), দ্বিতীয় নোডে পাব তৃতীয় নোডের এড্রেস(যদি থাকে)… এভাবে চলতে চলতে যখন কোন নোডে আর কোন এড্রেস থাকব না, তখন আমরা বুঝব আমাদের লিস্ট এখানেই শেষ। নিচের ছবিটি দেখলে ব্যাপারটি পরিষ্কার হয়ে যাবেঃ . . এখানে, আমরা যদি বক্সগুলোকে নোড হিসেবে চিন্তা করি তাহলে ঘাসগুলো হল আমাদের ডাটা এবং পরবর্তী বক্সের এড্রেসটা হল পয়েন্টার পার্ট। আমাদের এখানে সবগুলো বক্সের এড্রেস না জানলেও আমরা কিন্তু শুধুমাত্র একটি বক্সের এড্রেস দিয়েই সবগুলো বক্সকে এড্রেস করতে পেরেছি। এখানে আমরা শুধু প্রথম বক্সের এড্রেসই জানতাম। যেহেতু প্রতিটি বক্সে তার সংলগ্ন একটি বক্সের(যদি থাকে) এড্রেস ছিল তাই আমরা কোন সমস্যা ছাড়াই বাকি বক্স এবং ‘ঘাস-পাতা’গুলো খুবই সহজে পেয়ে গেছি। লিংকড লিস্টের কার্যপদ্ধতিও সম্পূর্ণভাবে একইরকম। . লিংকড লিস্টের প্রকারভেদ . লিংকড লিস্ট অনেক রকমের হতে পারে। তবে আমরা পরবর্তীতে শুধুমাত্র তিন ধরণের নিয়ে আলোচনা করব। এরা হলঃ . Singly Linked List | Doubly Linked List | Circular Linked List | . এই তিনপ্রকারের লিংকড লিস্ট নিয়ে পরবর্তী ব্লগে আলোচনা করা হবে। .",
            "url": "https://afifaniks.github.io/blog/c%20programming/bangla/2017/04/10/linked-list-in-c.html",
            "relUrl": "/c%20programming/bangla/2017/04/10/linked-list-in-c.html",
            "date": " • Apr 10, 2017"
        }
        
    
  
    
        ,"post4": {
            "title": "স্ট্রাকচারের পয়েন্টার - সি প্রোগ্রামিং",
            "content": "স্ট্রাকচারের পয়েন্টার . পয়েন্টার কি? . আমরা সবাই জানি পয়েন্টার কি। পয়েন্টার হল এক ধরণের ভ্যারিয়েবল যে অন্য ভ্যারিয়েবলের এড্রেস ধরে রাখে। পয়েন্টার কিভাবে কাজ করে তাও আশা করি আমরা সবাই মোটামুটি জানি। এখানে আমরা পয়েন্টারের ব্যাসিক নিয়ে তেমন আলোচনা করব না। আমরা এখানে যে বিষয়টি নিয়ে আলোচনা করব সেটি হচ্ছে, স্ট্রাকচারের পয়েন্টার। তবে পরের অংশটুকু বুঝে পড়ার জন্য পয়েন্টার সম্পর্কে ধারণা থাকা খুবই জরুরি। . স্ট্রাকচারের পয়েন্টার . এটা আমাদের সবারই জানা যে, কোন পয়েন্টার ডিক্লেয়ার করার আগে আমাদের ঐ পয়েন্টারের টাইপ বলে দিতে হয়। কারণ ঐ পয়েন্টার তো আর জানে না যে সে কোন টাইপের ভ্যারিয়বলের এড্রেস রাখবে। মনে হতে পারে যে, তার কাজতো শুধু এড্রেসই ধরে রাখা তবে টাইপ দেয়ার দরকার টা কি! দরকার আছে। আমরা জানি যে, বিভিন্ন ডাটা টাইপ মেমোরিতে বিভিন্ন রকম জায়গা নেয়। যেমন কোন char টাইপ ভ্যারিয়েবল ১ বাইট জায়গা নেয়, যেখানে int টাইপ নেয় ৪ বাইট। এখন আমরা যখন ইন্টিজার টাইপের পয়েন্টার ডিক্লেয়ার করি তখন সে তার পয়েন্টিং এড্রেসের পরবর্তী ৪ বাইটের এড্রেসের জন্যে ডাটা রিড করবে, যেখানে ক্যারেক্টার টাইপ করবে শুধুমাত্র পরবর্তী বাইটের জন্য। আশা করি, টাইপের ব্যাপারটা এবার পরিষ্কার! এবার আসা যাক স্ট্রাকচারের পয়েন্টারে। আমরা এতক্ষণ দেখেছি যে বিভিন্ন ডাটা টাইপের জন্য তাদের নিজস্ব টাইপের পয়েন্টার হয়। আবার স্ট্রাকচারও যেহেতু এক ধরণের ইউজার ডিফাইন্ড ডাটা টাইপ এবং স্বভাবতই ডিক্লেয়ার করার সাথে সাথে স্ট্রাকচার মেমোরিতে প্রয়োজনমত জায়গা নিবে সুতরাং তারও পয়েন্টার ডিক্লেয়ার করা যায়। স্ট্রাকচারের পয়েন্টারের কর্মক্ষেত্র অনেক ব্যাপক। অনেক ধরণের ডাটা স্ট্রাকচার শুধুমাত্র স্ট্রাকচারের পয়েন্টারের ধারণায় তৈরি হয়েছে। যার কিছু আমরা পরবর্তিতে দেখব। গত অধ্যায়ে আমরা দেখেছি কিভাবে ডট অপারেটর দিয়ে আমরা স্ট্রাকচারের মেম্বারদের অ্যাক্সেস করতে পারি। আমরা কিন্তু চাইলে পয়েন্টার দিয়েও কাজটা করে ফেলতে পারি। সেক্ষেত্রে আমাদের আরেকটি অপারেটর আছে যেটির ব্যবহার আমরা একটু পরেই দেখব। আপাতত নিচের উদাহরণটি লক্ষ্য করা যাকঃ . struct Man { char name[10]; int age; }; struct Man *pointerForMan; . এখানে প্রথমে আমরা আগের মতই একটি স্ট্রাকচার ডিক্লেয়ার করেছি যার নাম Man. এতে দুইটি ফিল্ড আছে। যার একটি নাম, অপরটি বয়স। তারপর আমরা যে কাজটি করেছি সেটি হল, আমাদের ডিক্লেয়ার করা স্ট্রাকচার টাইপের একটি পয়েন্টার ডিক্লেয়ার করেছি। এখানে struct Man এইটা হচ্ছে আমদের পয়েন্টারের টাইপ। struct দিয়ে আমরা বুঝাচ্ছি যে এটি একটি স্ট্রাকচার এবং পরের Man দ্বারা আমরা আমাদের ডিক্লেয়ার করা স্ট্রাকচারটিকে নির্দেশ করছি। আর বাকিটা তো সাধারণ পয়েন্টার ডিক্লারেশানের মতই। আশা করি, এতটুকু বুঝতে কোন প্রবলেম নেই। একটু আধটু থাকলেও দুই একটা উদাহরণ দেখলেই পরিষ্কার হয়ে যাবে। এখন আমরা যদি এই স্ট্রাকচারের জন্য একটি ভ্যারিয়বল ডিক্লেয়ার করি এবং এর এড্রেস আমাদের ডিক্লেয়ার করে পয়েন্টার *pointerForMan এ এসাইন করে দেই, তাহলে সেটি অন্যান্য পয়েন্টার যেভাবে কাজ করে ঠিক সেভাবেই কাজ করবে। নিচের প্রোগ্রামটি লক্ষ্য করা যাকঃ . #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct Man { char name[10]; int age; }; int main() { struct Man Man1; struct Man *pointerForMan; strcpy(Man1.name, &quot;Abul&quot;); Man1.age = 102; pointerForMan = &amp;Man1; printf(&quot;%s %d n&quot;, Man1.name, Man1.age); //Print1 printf(&quot;%s %d n&quot;, pointerForMan-&gt;name, pointerForMan-&gt;age); //Print2 return 0; } . উপরের কোডটি রান কর। কি দেখতে পেলে? সব ঠিকঠাক থাকলে নিচের ছবির মত আউটপুট দেখতে পাওয়ার কথা। লক্ষ্য কর, এখানে একই লাইন দুইবার দেখা যাচ্ছে। . . কোডের দিকে তাকালে দেখতে পাবে আমরা Print1 লাইনটিতে নরমালি স্ট্রাকচার ভ্যারিয়েবল থেকে ডাটা প্রিন্ট করেছি। কিন্তু দ্বিতীয় লাইনে(Print2) আমরা যেটা করেছি সেটা হল, আমরা পয়েন্টার দিয়ে কাজটা করেছি। উপরের কোডে আমরা প্রথমে Man1 নামে একটি স্ট্রাকচার ভ্যারিয়েবল ডিক্লেয়ার করেছি। এবং তারপর একই টাইপের একটি পয়েন্টার pointerForMan ডিক্লেয়ার করেছি। তারপর, Man1 এর জন্য প্রয়োজনমত ইনপুট নিয়ে Man1 এর রেফারেন্স পয়েন্টারটিতে এসাইন করে দিয়েছি। এখন কথা হচ্ছে, Print2 তে আমরা কাজটি কিভাবে করলাম? আমরা এখানে একটি ‘নতুন’ অপারেটর ব্যবহার করেছি। অপারেটরটি হল ‘-&gt;’(Structure pointer operator). এই অপারেটরটি দিয়ে মূলত পয়েন্টারের মাধ্যমে আমরা কোন স্ট্রাকচারের মেম্বারকে এক্সেস করতে পারি। আমরা চাইলে কোন স্ট্রাকচার ভ্যারিয়েবল ছাড়াই শুধুমাত্র পয়েন্টার এবং এই অপারেটর ব্যবহার করে কোন স্ট্রাকচারের যেকোন ফিল্ডের ভ্যালু এসাইন, চেঞ্জ করতে পারি। তবে সেক্ষেত্রে আমাদের ডায়নামিকালি মেমোরি এলোকেট করে নিতে হবে। সেটা আমরা পরের অধ্যায়ে দেখব। এবার তুমি নিজে নিজে একই ভাবে, একটি স্ট্রাকচার ডিক্লেয়ার করে সেই স্ট্রাকচারের জন্য দুইটি ভ্যারিয়েবল এবং দুইটি পয়েন্টার ডিক্লেয়ার করে পয়েন্টার দিয়ে স্ট্রাকচারের মেম্বারগুলোর ভ্যালু প্রিন্ট করার চেষ্টা কর। চাইলে নিচের Example স্ট্রাকচারটি ব্যবহার করতে পার। . struct Example { int data; double data2; char data3; }; .",
            "url": "https://afifaniks.github.io/blog/c%20programming/bangla/2017/04/01/pointer-of-structures.html",
            "relUrl": "/c%20programming/bangla/2017/04/01/pointer-of-structures.html",
            "date": " • Apr 1, 2017"
        }
        
    
  
    
        ,"post5": {
            "title": "স্ট্রাকচার - সি প্রোগ্রামিং",
            "content": "স্ট্রাকচার . স্ট্রাকচার কি? . সি প্রোগ্রামিংয়ে স্ট্রাকচার হচ্ছে এক ধরনের ইউজার ডিফাইন্ড ডাটা টাইপ। আবার একে বিভিন্ন ডাটা টাইপের একটি কালেকশনও বলা যেতে পারে। . এত কিছু থাকতে স্ট্রাকচার কেন? . ধরা যাক, আমাদের কাছে কয়েকটা গরুর বয়স, নাম(কল্পিত) এবং রঙ দেয়া আছে। আমরা চাচ্ছি সবগুলো ডাটা স্টোর করে রাখতে। কিভাবে কাজটা করা যেতে পারে? ধরা যাক, আমরা তিনটা গরুর জন্য উপরের ডাটাগুলো স্টোর করে রাখতে চাই। তাহলে কি ৩*৩ = ৯ টা আলাদা ভ্যারিয়েবল ডিক্লেয়ার করে একটা একটা করে ভ্যালু এসাইন করে দিব? হ্যাঁ করা যেতেই পারে(!) কিন্তু গরুর সংখ্যা যদি বেড়ে ১০০ হয়ে যায়? ৩০০ ভ্যারিয়েবল ডিক্লেয়ার নিশ্চয়ই কেউ করতে চাইব না। কোনো ভাবে অনেক ধৈর্য নিয়ে যদি করাও যায়, তবুও এত গুলো গরুর জন্য স্পেসিফিক কোন গরুর রেফারেন্সে স্পেসিফিক কোন ডাটার রেফারেন্স রাখা কি খুব সহজ হবে? হবে না! কেউ কেউ হয়ত ভাবছি আমরা তিনটা অ্যারে ডিক্লেয়ার করলেই তো পারি! হ্যাঁ, থিওরিটিকালি পারি। আবার কোন কোন সময় পারিও না! কেন পারিনা তা আমরা যখন লিংকড লিস্ট পড়ব তখন দেখে নেব। আবার, আমরা যদি ‘গরু১’, ‘গরু২’, ‘গরু৩’ নামে মাত্র তিনটি ভ্যারিয়েবল দিয়েই কাজটা করা যেত? ব্যাপারটা সহজ হত না! . Here comes Structure for you. . সোজা বাংলায় বলতে গেলে স্ট্রাকচার দিয়ে আমরা খুব সহজেই উপরের সব বৈশিষ্ট্যসহ একটি গরু বানিয়ে ফেলতে পারি। এবার দেখে নেয়া যাক কিভাবে আমরা কাজটা করতে পারি। . স্ট্রাকচারের ব্যবহার . একটি স্ট্রাকচার ডিফাইন করতে আমাদের একটি কি-ওয়ার্ড লাগে। কি-ওয়ার্ড টি হচ্ছে: . struct . এই কি-ওয়ার্ডটি দিয়েই আমরা নিজেদের ইচ্ছামত/প্রয়োজনমত একটি নতুন টাইপের ‘গরু’ আই মিন ডাটা টাইপ বানিয়ে ফেলতে পারি। যেহেতু আমরা হচ্ছি ইউজার, আর এটা আমাদের ডিফাইন করা ডাটা টাইপ, তাই এটি ইউজার ডিফাইন্ড ডাটা টাইপ। . এবার দেখা যাক আমরা উপরের বৈশিষ্ট্যগুলো সহ একটা গরু কিভাবে বানাতে পারি! . struct Goru { int boyos; char nam[10]; char rong[20]; }; . খুবই সহজে এভাবে স্ট্রাকচার দিয়ে আমরা গরু, হাতি, ডায়নোসরসহ আমাদের ইচ্ছামত যা খুশি বানিয়ে ফেলতে পারি। এখানে প্রথম লাইনের struct Goru মানে হচ্ছে আমরা Goru টাইপের ডাটা বানিয়ে ফেলেছি যার ভেতরে boyos, nam, rong নামের কয়েকটি বৈশিষ্ট্য আছে। এই বৈশিষ্ট্যগুলোকে প্রোগ্রামিংয়ের কনটেক্সটে কোন স্ট্রাকচারের member বলা হয়। আমরা স্ট্রাকচারের কোন ভ্যারিয়েবল ইনিশিয়ালাইজ(ডিক্লেয়ার আর কি) করে এই মেম্বারদের অ্যাক্সেস করতে পারি এবং ম্যানিপুলেট করতে পারি। ওহ, আরেকটা ব্যাপার, স্ট্রাকচারের শেষের কার্লি ব্রেসের পরের সেমিকোলন দিতে আমরা অনেকসময় ভুলে যাই। এটা ভুলে গেলে চলবে না। স্ট্রাকচার কোন ফাংশান না। এটি একটি স্ট্যাটমেন্টের মতই কাজ করে। তাই, সেমিকোলন ব্যবহার করা বাঞ্ছনীয়। . এবার নিচের ছবিটি লক্ষ্য করা যাকঃ . . উপরের ছবিতে অদ্ভুত দর্শন যে তিনটি স্ট্রাকচার দেখে যাচ্ছে ধরে নেয়া যাক এইগুলো আমাদের গরু। তিনটি গরুরই বৈশিষ্ট্য একই রকম যেরকম আমরা উপরে স্ট্রাকচারটি ডিফাইন করে এসেছি। এবার সি প্রোগ্রামের কনটেক্সটে দেখে নেয়া যাক আমরা কিভাবে এর কোড করতে পারি। . #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct Goru { int boyos; char nam[10]; char rong[20]; }; int main() { struct Goru goru1; struct Goru goru2; struct Goru goru3; //Assigning data for Goru 1 goru1.boyos = 12; strcpy(goru1.nam, &quot;Lali&quot;); strcpy(goru1.rong, &quot;Lal&quot;); printf(&quot;Name: %s nColor: %s nBoyos: %d n&quot;,goru1.nam, goru1.rong, goru1.boyos); //Assign data for Goru 2 and Goru 3 the same way as Goru 1 //Your code goes here... return 0; } . এখানে main() এর শুরুতে আমরা প্রথমেই তিনটি গরুর জন্যে তিনটি ভ্যারিয়েবল ডিক্লেয়ার করে নিয়েছি ঠিক যেভাবে আমরা কোন ভ্যারিয়েবল ডিক্লেয়ার করি। তারপর আমরা একে একে গরুর সবগুলো ডাটা এসাইন করে দিয়েছি। এখানে একটা বিষয় লক্ষণীয় যে, কোন স্ট্রাকচারের মেম্বারকে এক্সেস করতে সাধারণত ’.’ (ডট) অপারেটর ব্যবহার করা হয়। আমরা যখন লিখছি goru1.boyos তার মানে হল আমরা ঐ স্ট্রাকচারের মেম্বার boyos কে এক্সেস করেছি। তারপর ঐ মেম্বারের জন্য একটি ডাটা ১২(গরুর বয়স) এসাইন করে দিয়েছি। পরের দুই লাইনে নাম ও রঙের জন্য যেই দুটি মেম্বার ছিল সে দুটির জন্য দুটি স্ট্রিং এসাইন করেছি। ঠিক একইভাবে আমরা প্রিন্ট ফাংশানে ডট অপারেটর দিয়ে স্ট্রাকচারে থাকা এলিমেন্টগুলোর ভ্যালু প্রিন্ট করেছি। এখন মনে হয়ত প্রশ্ন জাগতে পারে যে শেষমেশ তো একটি গরুর জন্য তিনটি ফিল্ড নিয়েই কাজ করতে হচ্ছে। তাহলে স্ট্রাকচার ব্যবহার করে আমাদের লাভটা কি হল? আসলে একটু লক্ষ্য করলেই দেখা যাবে আমাদের কিন্তু তিনটি ফিল্ড তিনটি গরুর জন্য আলাদাভাবে ডিক্লেয়ার করতে হয় নি বরং আমরা একটি গরুর জন্য একটি ভ্যারিয়েবলই ডিক্লেয়ার করেছি। কারণ, আমরা প্রথম যখন স্ট্রাকচারটি বানিয়েছি তখনই বলে দিয়েছি এর বৈশিষ্ট্যগুলো কি হবে মানে এতে কোন কোন এলিমেন্ট থাকবে। যে কারণে পরবর্তীতে আমরা যখনই ঐ স্ট্রাকচারের একটি ভ্যারিয়েবল ডিক্লেয়ার করছি তখন অটোমেটিকালিই এই তিনটি বৈশিষ্ট্যই আমাদের ভ্যারিয়েবলের সাথে চলে এসেছে যা আমরা ডট দিয়ে এক্সেস করতে পারি। আর সে কারণেই একটি ভ্যারিয়বল ডিক্লেয়ার করে তিনটি জিনিসই আমরা রাখতে পারছি। এভাবে কোন ভ্যারিয়েবলের রেফারেন্স রাখাও বেশ সহজ। আশা করি স্ট্রাকচারের সুবিধা আমরা সবাই মোটামুটি আন্দাজ করতে পারছি। এবার তোমরা একইভাবে গরু ২ এবং ৩ এর জন্য ভ্যালু এসাইন করে প্রিন্ট করার চেষ্টা কর। পরবর্তী চাপ্টারে আমরা দেখার চেষ্টা করব যে, কিভাবে স্ট্রাকচারের পয়েন্টার নিয়ে কাজ করা যায়। .",
            "url": "https://afifaniks.github.io/blog/c%20programming/bangla/2017/03/01/c-structure.html",
            "relUrl": "/c%20programming/bangla/2017/03/01/c-structure.html",
            "date": " • Mar 1, 2017"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "Afif Al Mamun . Afif Al Mamun is a software engineer from Dhaka, Bangladesh. He is currently working at Infolytx Bangladesh Ltd. as a software engineer in machine learning. Previously, he used to work at ServicEngine Ltd. as a software engineer where his main role was to develop web scrapers as per clients’ requirements and also developing modules in Java for the company framework. Being an AI enthusiast, he is actively researching in the field of Deep Learning &amp; Computer Vision and has published a few scholarly articles. Afif obtained his bachelor degree from the Department of Computer Science and Engineering of Daffodil International University. He received the 50 Years Victory of Bangladesh Gold Medal on the 9th convocation of the university held in 2022. During his study in the university, he collaborated with instructors as a student prefect. . To learn more about Afif, please navigate to https://afifaniks.github.io. . Thanks! .",
          "url": "https://afifaniks.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://afifaniks.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}